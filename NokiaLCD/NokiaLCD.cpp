/****************************************************/
/* Example Program For LCD6610 (NPX)                */
/* MCU      : Arduino Nano                          */
/* By       : Gravitech                             */
/* Function : Demo Interface LCD6610                */
/*            (Philips controller)                  */ 
/****************************************************/
/* Interface LCD6610 to Arduino Nano                */
/*    Nano  --> LCD6610                             */
/*    D2    --> BL                                  */
/*    D3    --> #CS                                 */
/*    D4    --> SCLK                                */
/*    D5    --> SDATA                               */
/*    D6    --> #RESEET                             */
/*    +5V   --> VCC,VBL                             */
/*    GND   --> GND                                 */
/****************************************************/

#include <avr/pgmspace.h>
#include "WProgram.h"
#include "NokiaLCD.h"

/* Define LCD6610 PinIO interface */
#define BL    2      // Digital 2 --> BL
#define CS    3      // Digital 3 --> #CS
#define CLK   4      // Digital 4 --> SCLK
#define SDA   5      // Digital 5 --> SDATA
#define RESET 6      // Digital 6 --> #RESET

/* Start of Define Philips(NXP):PCF8833 Header */ 
#define NOP 0x00 	// nop
#define SWRESET  0x01 	// software reset
#define BSTROFF  0x02 	// booster voltage OFF
#define BSTRON   0x03 	// booster voltage ON
#define RDDIDIF  0x04 	// read display identification
#define RDDST    0x09 	// read display status
#define SLEEPIN  0x10 	// sleep in
#define SLEEPOUT 0x11 	// sleep out
#define PTLON    0x12 	// partial display mode
#define NORON    0x13 	// display normal mode
#define INVOFF   0x20 	// inversion OFF
#define INVON    0x21 	// inversion ON
#define DALO     0x22 	// all pixel OFF
#define DAL      0x23 	// all pixel ON
#define SETCON   0x25 	// write contrast
#define DISPOFF  0x28 	// display OFF
#define DISPON   0x29 	// display ON
#define CASET    0x2A 	// column address set
#define PASET    0x2B 	// page address set
#define RAMWR    0x2C 	// memory write
#define RGBSET   0x2D 	// colour set
#define PTLAR    0x30 	// partial area
#define VSCRDEF  0x33 	// vertical scrolling definition
#define TEOFF    0x34 	// test mode
#define TEON     0x35 	// test mode
#define MADCTL   0x36 	// memory access control
#define SEP      0x37 	// vertical scrolling start address
#define IDMOFF   0x38 	// idle mode OFF
#define IDMON    0x39 	// idle mode ON
#define COLMOD   0x3A 	// interface pixel format
#define SETVOP   0xB0 	// set Vop
#define BRS      0xB4 	// bottom row swap
#define TRS      0xB6 	// top row swap
#define DISCTR   0xB9 	// display control
//#define DAOR   0xBA 	// data order(DOR)
#define TCDFE    0xBD 	// enable/disable DF temperature compensation
#define TCVOPE   0xBF 	// enable/disable Vop temp comp
#define EC       0xC0 	// internal or external oscillator
#define SETMUL   0xC2 	// set multiplication factor
#define TCVOPAB  0xC3 	// set TCVOP slopes A and B
#define TCVOPCD  0xC4 	// set TCVOP slopes c and d
#define TCDF     0xC5 	// set divider frequency
#define DF8COLOR 0xC6 	// set divider frequency 8-color mode
#define SETBS    0xC7 	// set bias system
#define RDTEMP   0xC8 	// temperature read back
#define NLI      0xC9 	// n-line inversion
#define RDID1    0xDA 	// read ID1
#define RDID2    0xDB 	// read ID2
#define RDID3    0xDC 	// read ID3

// Font sizes
#define SMALL 0
#define MEDIUM 1
#define LARGE 2

// Booleans
#define NOFILL 0
#define FILL 1

// 12-bit color definitions
#define WHITE 0xFFF
#define BLACK 0x000
#define RED 0xF00
#define GREEN 0x0F0
#define BLUE 0x00F
#define CYAN 0x0FF
#define MAGENTA 0xF0F
#define YELLOW 0xFF0
#define BROWN 0xB22
#define ORANGE 0xFA0
#define PINK 0xF6A

/*
#define WHITE 0x000
#define BLACK 0xFFF
#define RED 0xF00
//#define RED 0xFF0
#define GREEN 0xF0F
#define BLUE 0x0FF
#define CYAN 0x00F
#define MAGENTA 0x0F0
#define YELLOW 0xF00
#define BROWN 0xDD4
#define ORANGE 0xF50
#define PINK 0x590
*/
#define cbi(reg, bit) (reg&=~(1<<bit))
#define sbi(reg, bit) (reg|= (1<<bit))

#define CS0 cbi(PORTD,CS);
#define CS1 sbi(PORTD,CS);
#define CLK0 cbi(PORTD,CLK);
#define CLK1 sbi(PORTD,CLK);
#define SDA0 cbi(PORTD,SDA);
#define SDA1 sbi(PORTD,SDA);
#define RESET0 cbi(PORTD,RESET);
#define RESET1 sbi(PORTD,RESET);
#define BL0 cbi(PORTD,BL);
#define BL1 sbi(PORTD,BL);
/* End of Define Philips(NXP):PCF8833 Header */ 

const unsigned char FONT6x8[] PROGMEM = {
  0x06,0x08,0x08,0x00,0x00,0x00,0x00,0x00, // columns, rows, num_bytes_per_char
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // space 0x20
  0x20,0x20,0x20,0x20,0x20,0x00,0x20,0x00, // !
  0x50,0x50,0x50,0x00,0x00,0x00,0x00,0x00, // "
  0x50,0x50,0xF8,0x50,0xF8,0x50,0x50,0x00, // #
  0x20,0x78,0xA0,0x70,0x28,0xF0,0x20,0x00, // $
  0xC0,0xC8,0x10,0x20,0x40,0x98,0x18,0x00, // %
  0x40,0xA0,0xA0,0x40,0xA8,0x90,0x68,0x00, // &
  0x30,0x30,0x20,0x40,0x00,0x00,0x00,0x00, // '
  0x10,0x20,0x40,0x40,0x40,0x20,0x10,0x00, // (
  0x40,0x20,0x10,0x10,0x10,0x20,0x40,0x00, // )
  0x00,0x20,0xA8,0x70,0x70,0xA8,0x20,0x00, // *
  0x00,0x20,0x20,0xF8,0x20,0x20,0x00,0x00, // +
  0x00,0x00,0x00,0x00,0x30,0x30,0x20,0x40, // ,
  0x00,0x00,0x00,0xF8,0x00,0x00,0x00,0x00, // -
  0x00,0x00,0x00,0x00,0x00,0x30,0x30,0x00, // .
  0x00,0x08,0x10,0x20,0x40,0x80,0x00,0x00, // / (forward slash)
  0x70,0x88,0x88,0xA8,0x88,0x88,0x70,0x00, // 0 0x30
  0x20,0x60,0x20,0x20,0x20,0x20,0x70,0x00, // 1
  0x70,0x88,0x08,0x70,0x80,0x80,0xF8,0x00, // 2
  0xF8,0x08,0x10,0x30,0x08,0x88,0x70,0x00, // 3
  0x10,0x30,0x50,0x90,0xF8,0x10,0x10,0x00, // 4
  0xF8,0x80,0xF0,0x08,0x08,0x88,0x70,0x00, // 5
  0x38,0x40,0x80,0xF0,0x88,0x88,0x70,0x00, // 6
  0xF8,0x08,0x08,0x10,0x20,0x40,0x80,0x00, // 7
  0x70,0x88,0x88,0x70,0x88,0x88,0x70,0x00, // 8
  0x70,0x88,0x88,0x78,0x08,0x10,0xE0,0x00, // 9
  0x00,0x00,0x20,0x00,0x20,0x00,0x00,0x00, // :
  0x00,0x00,0x20,0x00,0x20,0x20,0x40,0x00, // ;
  0x08,0x10,0x20,0x40,0x20,0x10,0x08,0x00, // <
  0x00,0x00,0xF8,0x00,0xF8,0x00,0x00,0x00, // =
  0x40,0x20,0x10,0x08,0x10,0x20,0x40,0x00, // >
  0x70,0x88,0x08,0x30,0x20,0x00,0x20,0x00, // ?
  0x70,0x88,0xA8,0xB8,0xB0,0x80,0x78,0x00, // @ 0x40
  0x20,0x50,0x88,0x88,0xF8,0x88,0x88,0x00, // A
  0xF0,0x88,0x88,0xF0,0x88,0x88,0xF0,0x00, // B
  0x70,0x88,0x80,0x80,0x80,0x88,0x70,0x00, // C
  0xF0,0x88,0x88,0x88,0x88,0x88,0xF0,0x00, // D
  0xF8,0x80,0x80,0xF0,0x80,0x80,0xF8,0x00, // E
  0xF8,0x80,0x80,0xF0,0x80,0x80,0x80,0x00, // F
  0x78,0x88,0x80,0x80,0x98,0x88,0x78,0x00, // G
  0x88,0x88,0x88,0xF8,0x88,0x88,0x88,0x00, // H
  0x70,0x20,0x20,0x20,0x20,0x20,0x70,0x00, // I
  0x38,0x10,0x10,0x10,0x10,0x90,0x60,0x00, // J
  0x88,0x90,0xA0,0xC0,0xA0,0x90,0x88,0x00, // K
  0x80,0x80,0x80,0x80,0x80,0x80,0xF8,0x00, // L
  0x88,0xD8,0xA8,0xA8,0xA8,0x88,0x88,0x00, // M
  0x88,0x88,0xC8,0xA8,0x98,0x88,0x88,0x00, // N
  0x70,0x88,0x88,0x88,0x88,0x88,0x70,0x00, // O
  0xF0,0x88,0x88,0xF0,0x80,0x80,0x80,0x00, // P 0x50
  0x70,0x88,0x88,0x88,0xA8,0x90,0x68,0x00, // Q
  0xF0,0x88,0x88,0xF0,0xA0,0x90,0x88,0x00, // R
  0x70,0x88,0x80,0x70,0x08,0x88,0x70,0x00, // S
  0xF8,0xA8,0x20,0x20,0x20,0x20,0x20,0x00, // T
  0x88,0x88,0x88,0x88,0x88,0x88,0x70,0x00, // U
  0x88,0x88,0x88,0x88,0x88,0x50,0x20,0x00, // V
  0x88,0x88,0x88,0xA8,0xA8,0xA8,0x50,0x00, // W
  0x88,0x88,0x50,0x20,0x50,0x88,0x88,0x00, // X
  0x88,0x88,0x50,0x20,0x20,0x20,0x20,0x00, // Y
  0xF8,0x08,0x10,0x70,0x40,0x80,0xF8,0x00, // Z
  0x78,0x40,0x40,0x40,0x40,0x40,0x78,0x00, // [
  0x00,0x80,0x40,0x20,0x10,0x08,0x00,0x00, // \ (back slash)
  0x78,0x08,0x08,0x08,0x08,0x08,0x78,0x00, // ]
  0x20,0x50,0x88,0x00,0x00,0x00,0x00,0x00, // ^
  0x00,0x00,0x00,0x00,0x00,0x00,0xF8,0x00, // _
  0x60,0x60,0x20,0x10,0x00,0x00,0x00,0x00, // ` 0x60
  0x00,0x00,0x60,0x10,0x70,0x90,0x78,0x00, // a
  0x80,0x80,0xB0,0xC8,0x88,0xC8,0xB0,0x00, // b
  0x00,0x00,0x70,0x88,0x80,0x88,0x70,0x00, // c
  0x08,0x08,0x68,0x98,0x88,0x98,0x68,0x00, // d
  0x00,0x00,0x70,0x88,0xF8,0x80,0x70,0x00, // e
  0x10,0x28,0x20,0x70,0x20,0x20,0x20,0x00, // f
  0x00,0x00,0x70,0x98,0x98,0x68,0x08,0x70, // g
  0x80,0x80,0xB0,0xC8,0x88,0x88,0x88,0x00, // h
  0x20,0x00,0x60,0x20,0x20,0x20,0x70,0x00, // i
  0x10,0x00,0x10,0x10,0x10,0x90,0x60,0x00, // j
  0x80,0x80,0x90,0xA0,0xC0,0xA0,0x90,0x00, // k
  0x60,0x20,0x20,0x20,0x20,0x20,0x70,0x00, // l
  0x00,0x00,0xD0,0xA8,0xA8,0xA8,0xA8,0x00, // m
  0x00,0x00,0xB0,0xC8,0x88,0x88,0x88,0x00, // n
  0x00,0x00,0x70,0x88,0x88,0x88,0x70,0x00, // o
  0x00,0x00,0xB0,0xC8,0xC8,0xB0,0x80,0x80, // p 0x70
  0x00,0x00,0x68,0x98,0x98,0x68,0x08,0x08, // q
  0x00,0x00,0xB0,0xC8,0x80,0x80,0x80,0x00, // r
  0x00,0x00,0x78,0x80,0x70,0x08,0xF0,0x00, // s
  0x20,0x20,0xF8,0x20,0x20,0x28,0x10,0x00, // t
  0x00,0x00,0x88,0x88,0x88,0x98,0x68,0x00, // u
  0x00,0x00,0x88,0x88,0x88,0x50,0x20,0x00, // v
  0x00,0x00,0x88,0x88,0xA8,0xA8,0x50,0x00, // w
  0x00,0x00,0x88,0x50,0x20,0x50,0x88,0x00, // x
  0x00,0x00,0x88,0x88,0x78,0x08,0x88,0x70, // y
  0x00,0x00,0xF8,0x10,0x20,0x40,0xF8,0x00, // z
  0x10,0x20,0x20,0x40,0x20,0x20,0x10,0x00, // {
  0x20,0x20,0x20,0x00,0x20,0x20,0x20,0x00, // |
  0x40,0x20,0x20,0x10,0x20,0x20,0x40,0x00, // }
  0x40,0xA8,0x10,0x00,0x00,0x00,0x00,0x00, // ~
  0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00}; // DEL

const unsigned char FONT8x8[] PROGMEM = {
  0x08,0x08,0x08,0x00,0x00,0x00,0x00,0x00, // columns, rows, num_bytes_per_char
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // space 0x20
  0x30,0x78,0x78,0x30,0x30,0x00,0x30,0x00, // !
  0x6C,0x6C,0x6C,0x00,0x00,0x00,0x00,0x00, // "
  0x6C,0x6C,0xFE,0x6C,0xFE,0x6C,0x6C,0x00, // #
  0x18,0x3E,0x60,0x3C,0x06,0x7C,0x18,0x00, // $
  0x00,0x63,0x66,0x0C,0x18,0x33,0x63,0x00, // %
  0x1C,0x36,0x1C,0x3B,0x6E,0x66,0x3B,0x00, // &
  0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00, // '
  0x0C,0x18,0x30,0x30,0x30,0x18,0x0C,0x00, // (
  0x30,0x18,0x0C,0x0C,0x0C,0x18,0x30,0x00, // )
  0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00, // *
  0x00,0x30,0x30,0xFC,0x30,0x30,0x00,0x00, // +
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30, // ,
  0x00,0x00,0x00,0x7E,0x00,0x00,0x00,0x00, // -
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00, // .
  0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00, // / (forward slash)
  0x3E,0x63,0x63,0x6B,0x63,0x63,0x3E,0x00, // 0 0x30
  0x18,0x38,0x58,0x18,0x18,0x18,0x7E,0x00, // 1
  0x3C,0x66,0x06,0x1C,0x30,0x66,0x7E,0x00, // 2
  0x3C,0x66,0x06,0x1C,0x06,0x66,0x3C,0x00, // 3
  0x0E,0x1E,0x36,0x66,0x7F,0x06,0x0F,0x00, // 4
  0x7E,0x60,0x7C,0x06,0x06,0x66,0x3C,0x00, // 5
  0x1C,0x30,0x60,0x7C,0x66,0x66,0x3C,0x00, // 6
  0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x00, // 7
  0x3C,0x66,0x66,0x3C,0x66,0x66,0x3C,0x00, // 8
  0x3C,0x66,0x66,0x3E,0x06,0x0C,0x38,0x00, // 9
  0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x00, // :
  0x00,0x18,0x18,0x00,0x00,0x18,0x18,0x30, // ;
  0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x00, // <
  0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00, // =
  0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x00, // >
  0x3C,0x66,0x06,0x0C,0x18,0x00,0x18,0x00, // ?
  0x3E,0x63,0x6F,0x69,0x6F,0x60,0x3E,0x00, // @ 0x40
  0x18,0x3C,0x66,0x66,0x7E,0x66,0x66,0x00, // A
  0x7E,0x33,0x33,0x3E,0x33,0x33,0x7E,0x00, // B
  0x1E,0x33,0x60,0x60,0x60,0x33,0x1E,0x00, // C
  0x7C,0x36,0x33,0x33,0x33,0x36,0x7C,0x00, // D
  0x7F,0x31,0x34,0x3C,0x34,0x31,0x7F,0x00, // E
  0x7F,0x31,0x34,0x3C,0x34,0x30,0x78,0x00, // F
  0x1E,0x33,0x60,0x60,0x67,0x33,0x1F,0x00, // G
  0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00, // H
  0x3C,0x18,0x18,0x18,0x18,0x18,0x3C,0x00, // I
  0x0F,0x06,0x06,0x06,0x66,0x66,0x3C,0x00, // J
  0x73,0x33,0x36,0x3C,0x36,0x33,0x73,0x00, // K
  0x78,0x30,0x30,0x30,0x31,0x33,0x7F,0x00, // L
  0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00, // M
  0x63,0x73,0x7B,0x6F,0x67,0x63,0x63,0x00, // N
  0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00, // O
  0x7E,0x33,0x33,0x3E,0x30,0x30,0x78,0x00, // P 0x50
  0x3C,0x66,0x66,0x66,0x6E,0x3C,0x0E,0x00, // Q
  0x7E,0x33,0x33,0x3E,0x36,0x33,0x73,0x00, // R
  0x3C,0x66,0x30,0x18,0x0C,0x66,0x3C,0x00, // S
  0x7E,0x5A,0x18,0x18,0x18,0x18,0x3C,0x00, // T
  0x66,0x66,0x66,0x66,0x66,0x66,0x7E,0x00, // U
  0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00, // V
  0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00, // W
  0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00, // X
  0x66,0x66,0x66,0x3C,0x18,0x18,0x3C,0x00, // Y
  0x7F,0x63,0x46,0x0C,0x19,0x33,0x7F,0x00, // Z
  0x3C,0x30,0x30,0x30,0x30,0x30,0x3C,0x00, // [
  0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00, // \ (back slash)
  0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00, // ]
  0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00, // ^
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF, // _
  0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00, // ` 0x60
  0x00,0x00,0x3C,0x06,0x3E,0x66,0x3B,0x00, // a
  0x70,0x30,0x3E,0x33,0x33,0x33,0x6E,0x00, // b
  0x00,0x00,0x3C,0x66,0x60,0x66,0x3C,0x00, // c
  0x0E,0x06,0x3E,0x66,0x66,0x66,0x3B,0x00, // d
  0x00,0x00,0x3C,0x66,0x7E,0x60,0x3C,0x00, // e
  0x1C,0x36,0x30,0x78,0x30,0x30,0x78,0x00, // f
  0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x7C, // g
  0x70,0x30,0x36,0x3B,0x33,0x33,0x73,0x00, // h
  0x18,0x00,0x38,0x18,0x18,0x18,0x3C,0x00, // i
  0x06,0x00,0x06,0x06,0x06,0x66,0x66,0x3C, // j
  0x70,0x30,0x33,0x36,0x3C,0x36,0x73,0x00, // k
  0x38,0x18,0x18,0x18,0x18,0x18,0x3C,0x00, // l
  0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x00, // m
  0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x00, // n
  0x00,0x00,0x3C,0x66,0x66,0x66,0x3C,0x00, // o
  0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78, // p 0x70
  0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F, // q
  0x00,0x00,0x6E,0x3B,0x33,0x30,0x78,0x00, // r
  0x00,0x00,0x3E,0x60,0x3C,0x06,0x7C,0x00, // s
  0x08,0x18,0x3E,0x18,0x18,0x1A,0x0C,0x00, // t
  0x00,0x00,0x66,0x66,0x66,0x66,0x3B,0x00, // u
  0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x00, // v
  0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00, // w
  0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00, // x
  0x00,0x00,0x66,0x66,0x66,0x3E,0x06,0x7C, // y
  0x00,0x00,0x7E,0x4C,0x18,0x32,0x7E,0x00, // z
  0x0E,0x18,0x18,0x70,0x18,0x18,0x0E,0x00, // {
  0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x0C,0x00, // |
  0x70,0x18,0x18,0x0E,0x18,0x18,0x70,0x00, // }
  0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00, // ~
  0x1C,0x36,0x36,0x1C,0x00,0x00,0x00,0x00}; // DEL

const unsigned char FONT8x16[] PROGMEM = {
  0x08,0x10,0x10,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // columns, rows, nbytes
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // space 0x20
  0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // !
  0x00,0x63,0x63,0x63,0x22,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // "
  0x00,0x00,0x00,0x36,0x36,0x7F,0x36,0x36,0x36,0x7F,0x36,0x36,0x00,0x00,0x00,0x00, // #
  0x0C,0x0C,0x3E,0x63,0x61,0x60,0x3E,0x03,0x03,0x43,0x63,0x3E,0x0C,0x0C,0x00,0x00, // $
  0x00,0x00,0x00,0x00,0x00,0x61,0x63,0x06,0x0C,0x18,0x33,0x63,0x00,0x00,0x00,0x00, // %
  0x00,0x00,0x00,0x1C,0x36,0x36,0x1C,0x3B,0x6E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00, // &
  0x00,0x30,0x30,0x30,0x60,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // '
  0x00,0x00,0x0C,0x18,0x18,0x30,0x30,0x30,0x30,0x18,0x18,0x0C,0x00,0x00,0x00,0x00, // (
  0x00,0x00,0x18,0x0C,0x0C,0x06,0x06,0x06,0x06,0x0C,0x0C,0x18,0x00,0x00,0x00,0x00, // )
  0x00,0x00,0x00,0x00,0x42,0x66,0x3C,0xFF,0x3C,0x66,0x42,0x00,0x00,0x00,0x00,0x00, // *
  0x00,0x00,0x00,0x00,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00, // +
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00, // ,
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // -
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // .
  0x00,0x00,0x01,0x03,0x07,0x0E,0x1C,0x38,0x70,0xE0,0xC0,0x80,0x00,0x00,0x00,0x00, // / (forward slash)
  0x00,0x00,0x3E,0x63,0x63,0x63,0x6B,0x6B,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // 0 0x30
  0x00,0x00,0x0C,0x1C,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3F,0x00,0x00,0x00,0x00, // 1
  0x00,0x00,0x3E,0x63,0x03,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00, // 2
  0x00,0x00,0x3E,0x63,0x03,0x03,0x1E,0x03,0x03,0x03,0x63,0x3E,0x00,0x00,0x00,0x00, // 3
  0x00,0x00,0x06,0x0E,0x1E,0x36,0x66,0x66,0x7F,0x06,0x06,0x0F,0x00,0x00,0x00,0x00, // 4
  0x00,0x00,0x7F,0x60,0x60,0x60,0x7E,0x03,0x03,0x63,0x73,0x3E,0x00,0x00,0x00,0x00, // 5
  0x00,0x00,0x1C,0x30,0x60,0x60,0x7E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // 6
  0x00,0x00,0x7F,0x63,0x03,0x06,0x06,0x0C,0x0C,0x18,0x18,0x18,0x00,0x00,0x00,0x00, // 7
  0x00,0x00,0x3E,0x63,0x63,0x63,0x3E,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // 8
  0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x3F,0x03,0x03,0x06,0x3C,0x00,0x00,0x00,0x00, // 9
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00, // :
  0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x18,0x30,0x00,0x00, // ;
  0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00, // <
  0x00,0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00, // =
  0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00, // >
  0x00,0x00,0x3E,0x63,0x63,0x06,0x0C,0x0C,0x0C,0x00,0x0C,0x0C,0x00,0x00,0x00,0x00, // ?
  0x00,0x00,0x3E,0x63,0x63,0x6F,0x6B,0x6B,0x6E,0x60,0x60,0x3E,0x00,0x00,0x00,0x00, // @ 0x40
  0x00,0x00,0x08,0x1C,0x36,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x00,0x00,0x00,0x00, // A
  0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x33,0x33,0x33,0x33,0x7E,0x00,0x00,0x00,0x00, // B
  0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x60,0x60,0x61,0x33,0x1E,0x00,0x00,0x00,0x00, // C
  0x00,0x00,0x7C,0x36,0x33,0x33,0x33,0x33,0x33,0x33,0x36,0x7C,0x00,0x00,0x00,0x00, // D
  0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00, // E
  0x00,0x00,0x7F,0x33,0x31,0x34,0x3C,0x34,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00, // F
  0x00,0x00,0x1E,0x33,0x61,0x60,0x60,0x6F,0x63,0x63,0x37,0x1D,0x00,0x00,0x00,0x00, // G
  0x00,0x00,0x63,0x63,0x63,0x63,0x7F,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00, // H
  0x00,0x00,0x3C,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // I
  0x00,0x00,0x0F,0x06,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00,0x00,0x00, // J
  0x00,0x00,0x73,0x33,0x36,0x36,0x3C,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00, // K
  0x00,0x00,0x78,0x30,0x30,0x30,0x30,0x30,0x30,0x31,0x33,0x7F,0x00,0x00,0x00,0x00, // L
  0x00,0x00,0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00, // M
  0x00,0x00,0x63,0x63,0x73,0x7B,0x7F,0x6F,0x67,0x63,0x63,0x63,0x00,0x00,0x00,0x00, // N
  0x00,0x00,0x1C,0x36,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x00,0x00,0x00,0x00, // O
  0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00, // P 0x50
  0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x63,0x6B,0x6F,0x3E,0x06,0x07,0x00,0x00, // Q
  0x00,0x00,0x7E,0x33,0x33,0x33,0x3E,0x36,0x36,0x33,0x33,0x73,0x00,0x00,0x00,0x00, // R
  0x00,0x00,0x3E,0x63,0x63,0x30,0x1C,0x06,0x03,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // S
  0x00,0x00,0xFF,0xDB,0x99,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // T
  0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // U
  0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x63,0x63,0x36,0x1C,0x08,0x00,0x00,0x00,0x00, // V
  0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x36,0x00,0x00,0x00,0x00, // W
  0x00,0x00,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x3C,0x66,0xC3,0xC3,0x00,0x00,0x00,0x00, // X
  0x00,0x00,0xC3,0xC3,0xC3,0x66,0x3C,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00, // Y
  0x00,0x00,0x7F,0x63,0x43,0x06,0x0C,0x18,0x30,0x61,0x63,0x7F,0x00,0x00,0x00,0x00, // Z
  0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00, // [
  0x00,0x00,0x80,0xC0,0xE0,0x70,0x38,0x1C,0x0E,0x07,0x03,0x01,0x00,0x00,0x00,0x00, // \ (back slash)
  0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00, // ]
  0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ^
  0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00, // _
  0x18,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ` 0x60
  0x00,0x00,0x00,0x00,0x00,0x3C,0x46,0x06,0x3E,0x66,0x66,0x3B,0x00,0x00,0x00,0x00, // a
  0x00,0x00,0x70,0x30,0x30,0x3C,0x36,0x33,0x33,0x33,0x33,0x6E,0x00,0x00,0x00,0x00, // b
  0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x60,0x60,0x60,0x63,0x3E,0x00,0x00,0x00,0x00, // c
  0x00,0x00,0x0E,0x06,0x06,0x1E,0x36,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00, // d
  0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x7E,0x60,0x63,0x3E,0x00,0x00,0x00,0x00, // e
  0x00,0x00,0x1C,0x36,0x32,0x30,0x7C,0x30,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00, // f
  0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x66,0x3C,0x00,0x00, // g
  0x00,0x00,0x70,0x30,0x30,0x36,0x3B,0x33,0x33,0x33,0x33,0x73,0x00,0x00,0x00,0x00, // h
  0x00,0x00,0x0C,0x0C,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00, // i
  0x00,0x00,0x06,0x06,0x00,0x0E,0x06,0x06,0x06,0x06,0x06,0x66,0x66,0x3C,0x00,0x00, // j
  0x00,0x00,0x70,0x30,0x30,0x33,0x33,0x36,0x3C,0x36,0x33,0x73,0x00,0x00,0x00,0x00, // k
  0x00,0x00,0x1C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00, // l
  0x00,0x00,0x00,0x00,0x00,0x6E,0x7F,0x6B,0x6B,0x6B,0x6B,0x6B,0x00,0x00,0x00,0x00, // m
  0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x33,0x33,0x00,0x00,0x00,0x00, // n
  0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x63,0x63,0x63,0x63,0x3E,0x00,0x00,0x00,0x00, // o
  0x00,0x00,0x00,0x00,0x00,0x6E,0x33,0x33,0x33,0x33,0x3E,0x30,0x30,0x78,0x00,0x00, // p 0x70
  0x00,0x00,0x00,0x00,0x00,0x3B,0x66,0x66,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00,0x00, // q
  0x00,0x00,0x00,0x00,0x00,0x6E,0x3B,0x33,0x30,0x30,0x30,0x78,0x00,0x00,0x00,0x00, // r
  0x00,0x00,0x00,0x00,0x00,0x3E,0x63,0x38,0x0E,0x03,0x63,0x3E,0x00,0x00,0x00,0x00, // s
  0x00,0x00,0x08,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x1B,0x0E,0x00,0x00,0x00,0x00, // t
  0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x3B,0x00,0x00,0x00,0x00, // u
  0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x36,0x36,0x1C,0x1C,0x08,0x00,0x00,0x00,0x00, // v
  0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x6B,0x6B,0x7F,0x36,0x00,0x00,0x00,0x00, // w
  0x00,0x00,0x00,0x00,0x00,0x63,0x36,0x1C,0x1C,0x1C,0x36,0x63,0x00,0x00,0x00,0x00, // x
  0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x63,0x63,0x63,0x3F,0x03,0x06,0x3C,0x00,0x00, // y
  0x00,0x00,0x00,0x00,0x00,0x7F,0x66,0x0C,0x18,0x30,0x63,0x7F,0x00,0x00,0x00,0x00, // z
  0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00, // {
  0x00,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00, // |
  0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00, // }
  0x00,0x00,0x3B,0x6E,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00, // ~
  0x00,0x70,0xD8,0xD8,0x70,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}; // DEL


/**************************************/
/*        Sending command             */
/**************************************/
void NokiaLCD::sendCMD(byte data) 
{
  CS1
  CLK0
  CS0
  SDA0
  CLK1
  CLK0

  shiftBits(data);
  CLK0
  CS1
}
/**************************************/
/*        Sending data                */
/**************************************/
void NokiaLCD::sendData(byte data) {
  
  CS1
  CLK0
  CS0
  SDA1
  CLK1
  CLK0

  shiftBits(data);
  CLK0
  CS1
}
/**************************************/
/*        Shifting SPI bit out        */
/**************************************/
void NokiaLCD::shiftBits(byte data) 
{
  byte Bit;
  
  for (Bit = 0; Bit < 8; Bit++)     // 8 Bit Write
  {
    CLK0          // Standby SCLK
    if((data&0x80)>>7)
    {
      SDA1
    }
    else
    {
      SDA0
    }
    CLK1          // Strobe signal bit 
    data <<= 1;   // Next bit data
  }  
}
/**************************************/
/*        Initialize LCD              */
/**************************************/
void NokiaLCD::lcd_init()
{
  // Initial state
  CLK0
  CS1
  SDA1
  
  // Hardware Reset LCD
  RESET0
  delay(100);
  RESET1
  delay(100);
  
  // Sleep out (commmand 0x11)
  sendCMD(SLEEPOUT);
  
  // Inversion on (command 0x20)
  //sendCMD(INVON);    // seems to be required for this controller
  sendCMD(INVOFF); 
  
  // Color Interface Pixel Format (command 0x3A)
  sendCMD(COLMOD);
  sendData(0x03);    // 0x03 = 12 bits-per-pixel
  
  // Memory access controler (command 0x36)
  sendCMD(MADCTL);
  sendData(0xC8); // 0xC0 = mirror x and y, reverse rgb
  
  // Write contrast (command 0x25)
  sendCMD(SETCON);
  sendData(0x30); // contrast 0x30
  delay(1000);

  // Display On (command 0x29)
  sendCMD(DISPON);
}
/**************************************/
/*       Draw a demo color bar        */
/**************************************/
void NokiaLCD::draw_color_bar()
{
  lcd_clear(RED,0,0,131,33);
  lcd_clear(GREEN,0,34,131,66);
  lcd_clear(BLUE,0,67,131,99);
  lcd_clear(WHITE,0,100,131,131);
}
/**************************************/
/* Clear LCD from (x0,y0) to (x1,y1)  */
/**************************************/
void NokiaLCD::lcd_clear(uint16_t color, byte x0, byte y0, byte x1, byte y1)
{
  uint16_t xmin, xmax, ymin, ymax;
  uint16_t i;
  
  // best way to create a filled rectangle is to define a drawing box
  // and loop two pixels at a time
  // calculate the min and max for x and y directions
  xmin = (x0 <= x1) ? x0 : x1;
  xmax = (x0 > x1) ? x0 : x1;
  ymin = (y0 <= y1) ? y0 : y1;
  ymax = (y0 > y1) ? y0 : y1;

  // specify the controller drawing box according to those limits
  // Row address set (command 0x2B)
  sendCMD(PASET);
  sendData(xmin);
  sendData(xmax);

  // Column address set (command 0x2A)
  sendCMD(CASET);
  sendData(ymin);
  sendData(ymax);

  // WRITE MEMORY
  sendCMD(RAMWR);

  // loop on total number of pixels / 2
  for (i = 0; i < ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 1); i++) 
  {
    // use the color value to output three data bytes covering two pixels
    // For some reason, it has to send blue first then green and red
    sendData((color << 4) | ((color & 0xF0) >> 4));
    sendData(((color >> 4) & 0xF0) | (color & 0x0F));
    sendData((color & 0xF0) | (color >> 8));
  }
}
// *************************************************************************************************
// LCDPutStr.c
//
// Draws a null-terminates character string at the specified (x,y) address, size and color
//
// Inputs: pString = pointer to character string to be displayed
// x = row address (0 .. 131)
// y = column address (0 .. 131)
// Size = font pitch (SMALL, MEDIUM, LARGE)
// fColor = 12-bit foreground color value rrrrggggbbbb
// bColor = 12-bit background color value rrrrggggbbbb
//
//
// Returns: nothing
//
// Notes: Here's an example to display "Hello World!" at address (20,20)
//
// LCDPutChar("Hello World!", 20, 20, LARGE, WHITE, BLACK);
//
//
// Author: James P Lynch July 7, 2007
// *************************************************************************************************
void NokiaLCD::LCDPutStr(char *pString, int x, int y, int Size, int fColor, int bColor)
{
  // loop until null-terminator is seen
  while (*pString != 0x00) 
  {
    // draw the character
    LCDPutChar(*pString++, x, y, Size, fColor, bColor);

    // advance the y position
    if (Size == SMALL)
    y = y + 6;

    else if (Size == MEDIUM)
    y = y + 8;

    else
    y = y + 8;

    // bail out if y exceeds 131
    if (y > 131) break;
  }
}
// *****************************************************************************
// LCDPutChar.c
//
// Draws an ASCII character at the specified (x,y) address and color
//
// Inputs: c = character to be displayed
// x = row address (0 .. 131)
// y = column address (0 .. 131)
// size = font pitch (SMALL, MEDIUM, LARGE)
// fcolor = 12-bit foreground color value rrrrggggbbbb
// bcolor = 12-bit background color value rrrrggggbbbb
//
//
// Returns: nothing
//
//
// Notes: Here's an example to display "E" at address (20,20)
//
// LCDPutChar('E', 20, 20, MEDIUM, WHITE, BLACK);
//
// (27,20) (27,27)
// | |
// | |
// ^ V V
// : _ # # # # # # # 0x7F
// : _ _ # # _ _ _ # 0x31
// : _ _ # # _ # _ _ 0x34
// x _ _ # # # # _ _ 0x3C
// : _ _ # # _ # _ _ 0x34
// : _ _ # # _ _ _ # 0x31
// : _ # # # # # # # 0x7F
// : _ _ _ _ _ _ _ _ 0x00
//
// ------y------->
// ^ ^
// | |
// | |
// (20,20) (20,27)
//
//
// The most efficient way to display a character is to make use of the "wrap-around" feature
// of the Philips PCF8833 LCD controller chip.
//
// Assume that we position the character at (20, 20) that's a (row, col) specification.
// With the row and column address set commands, you can specify an 8x8 box for the SMALL and MEDIUM
// characters or a 16x8 box for the LARGE characters.
//
// WriteSpiCommand(PASET); // set the row drawing limits
// WriteSpiData(20); //
// WriteSpiData(27); // limit rows to (20, 27)
//
// WriteSpiCommand(CASET); // set the column drawing limits
// WriteSpiData(20); //
// WriteSpiData(27); // limit columns to (20,27)
//
// When the algorithm completes col 27, the column address wraps back to 20
// At the same time, the row address increases by one (this is done by the controller)
//
// We walk through each row, two pixels at a time. The purpose is to create three
// data bytes representing these two pixels in the following format (as specified by Philips
// for RGB 4 : 4 : 4 format (see page 62 of PCF8833 controller manual).
//
// Data for pixel 0: RRRRGGGGBBBB
// Data for Pixel 1: RRRRGGGGBBBB
//
// WriteSpiCommand(RAMWR); // start a memory write (96 data bytes to follow)
//
// WriteSpiData(RRRRGGGG); // first pixel, red and green data
// WriteSpiData(BBBBRRRR); // first pixel, blue data; second pixel, red data
// WriteSpiData(GGGGBBBB); // second pixel, green and blue data
// :
// and so on until all pixels displayed!
// :
// WriteSpiCommand(NOP); // this will terminate the RAMWR command
//
//
// Author: James P Lynch July 7, 2007
// *****************************************************************************
void NokiaLCD::LCDPutChar(char c, int x, int y, int size, int fColor, int bColor) 
{
  int i,j;
  unsigned int  nCols;
  unsigned int  nRows;
  unsigned int  nBytes;
  unsigned char PixelRow;
  unsigned char Mask;
  unsigned int  Word0;
  unsigned int  Word1;
  unsigned char *pFont;
  unsigned char *pChar;
  unsigned char *FontTable[] = {(unsigned char *)FONT6x8,
                                (unsigned char *)FONT8x8,
                                (unsigned char *)FONT8x16};

  // get pointer to the beginning of the selected font table
  pFont = (unsigned char *)FontTable[size];

  /* get the nColumns, nRows and nBytes */
  //nCols = *pFont;
  nCols  = pgm_read_byte(&*pFont);         // Array Flash
  //nRows = *(pFont + 1);
  nRows  = pgm_read_byte(&*(pFont + 1));   // Array Flash
  //nBytes = *(pFont + 2);
  nBytes = pgm_read_byte(&*(pFont + 2));   // Array Flash

  /* get pointer to the last byte of the desired character */
  //pChar = pFont + (nBytes * (c - 0x1F)) + nBytes - 1;
  pChar = pFont + (nBytes * (c - 0x1F));
  // Row address set (command 0x2B)
  sendCMD(PASET);
  sendData(x);
  sendData(x + nRows - 1);

  // Column address set (command 0x2A)
  sendCMD(CASET);
  sendData(y);
  sendData(y + nCols - 1);

  // WRITE MEMORY
  sendCMD(RAMWR);
  // loop on each row, working backwards from the bottom to the top
  for (i = nRows - 1; i >= 0; i--) 
  {
    /* copy pixel row from font table and then decrement row */
    //PixelRow = pgm_read_byte(&*pChar--);  // Array Flash
    //PixelRow = *pChar--;
    PixelRow = pgm_read_byte(&*pChar++);  // Array Flash

    // loop on each pixel in the row (left to right)
    // Note: we do two pixels each loop
    Mask = 0x80;
    for (j = 0; j < nCols; j += 2) 
	{
      // if pixel bit set, use foreground color; else use the background color
      // now get the pixel color for two successive pixels
      if ((PixelRow & Mask) == 0)
        Word0 = bColor;
      else
        Word0 = fColor;
      Mask = Mask >> 1;

      if ((PixelRow & Mask) == 0)
        Word1 = bColor;
      else
        Word1 = fColor;
      Mask = Mask >> 1;
      
      // use this information to output three data bytes
      // For some reason, it has to send blue first then green and red
      sendData((Word0 << 4) | ((Word0 & 0xF0) >> 4));
      sendData(((Word0 >> 4) & 0xF0) | (Word1 & 0x0F));
      sendData((Word1 & 0xF0) | (Word1 >> 8));
    }
  }

  // terminate the Write Memory command
  sendCMD(NOP);
}
// *************************************************************************************************
// LCDSetLine.c
//
// Draws a line in the specified color from (x0,y0) to (x1,y1)
//
// Inputs: x = row address (0 .. 131)
// y = column address (0 .. 131)
// color = 12-bit color value rrrrggggbbbb
// rrrr = 1111 full red
// :
// 0000 red is off
//
// gggg = 1111 full green
// :
// 0000 green is off
//
// bbbb = 1111 full blue
// :
// 0000 blue is off
//
// Returns: nothing
//
// Note: good write-up on this algorithm in Wikipedia (search for Bresenham's line algorithm)
// see lcd.h for some sample color settings
//
// Authors: Dr. Leonard McMillan, Associate Professor UNC
// Jack Bresenham IBM, Winthrop University (Father of this algorithm, 1962)
//
// Note: taken verbatim from Professor McMillan's presentation:
// http://www.cs.unc.edu/~mcmillan/comp136/Lecture6/Lines.html
//
// *************************************************************************************************
void NokiaLCD::LCDSetLine(int x0, int y0, int x1, int y1, int color) 
{
  int dy = y1 - y0;
  int dx = x1 - x0;
  int stepx, stepy;
  if (dy < 0) { dy = -dy; stepy = -1; } else { stepy = 1; }
  if (dx < 0) { dx = -dx; stepx = -1; } else { stepx = 1; }
  dy <<= 1; // dy is now 2*dy
  dx <<= 1; // dx is now 2*dx
  LCDSetPixel(x0, y0, color);
  if (dx > dy) 
  {
    int fraction = dy - (dx >> 1); // same as 2*dy - dx
    while (x0 != x1) 
    {
      if (fraction >= 0) 
      {
        y0 += stepy;
        fraction -= dx; // same as fraction -= 2*dx
      }
      x0 += stepx;
      fraction += dy; // same as fraction -= 2*dy
      LCDSetPixel(x0, y0, color);
    }
  } 
  else 
  {
    int fraction = dx - (dy >> 1);
    while (y0 != y1) 
	{
      if (fraction >= 0) 
	  {
        x0 += stepx;
        fraction -= dy;
      }
      y0 += stepy;
      fraction += dx;
      LCDSetPixel(x0, y0, color);
    }
  }
}
// *****************************************************************************************
// LCDSetRect.c
//
// Draws a rectangle in the specified color from (x1,y1) to (x2,y2)
// Rectangle can be filled with a color if desired
//
// Inputs: x = row address (0 .. 131)
// y = column address (0 .. 131)
// fill = 0=no fill, 1-fill entire rectangle
// color = 12-bit color value for lines rrrrggggbbbb
// rrrr = 1111 full red
// :
// 0000 red is off
//
// gggg = 1111 full green
// :
// 0000 green is off
//
// bbbb = 1111 full blue
// :
// 0000 blue is off
// Returns: nothing
//
// Notes:
//
// The best way to fill a rectangle is to take advantage of the "wrap-around" featute
// built into the Philips PCF8833 controller. By defining a drawing box, the memory can
// be simply filled by successive memory writes until all pixels have been illuminated.
//
// 1. Given the coordinates of two opposing corners (x0, y0) (x1, y1)
// calculate the minimums and maximums of the coordinates
//
// xmin = (x0 <= x1) ? x0 : x1;
// xmax = (x0 > x1) ? x0 : x1;
// ymin = (y0 <= y1) ? y0 : y1;
// ymax = (y0 > y1) ? y0 : y1;
//
// 2. Now set up the drawing box to be the desired rectangle
//
// WriteSpiCommand(PASET); // set the row boundaries
// WriteSpiData(xmin);
// WriteSpiData(xmax);
// WriteSpiCommand(CASET); // set the column boundaries
// WriteSpiData(ymin);
// WriteSpiData(ymax);
//
// 3. Calculate the number of pixels to be written divided by 2
//
// NumPixels = ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 1)
//
// You may notice that I added one pixel to the formula.
// This covers the case where the number of pixels is odd and we
// would lose one pixel due to rounding error. In the case of
// odd pixels, the number of pixels is exact.
// in the case of even pixels, we have one more pixel than
// needed, but it cannot be displayed because it is outside
// the drawing box.
//
// We divide by 2 because two pixels are represented by three bytes.
// So we work through the rectangle two pixels at a time.
//
// 4. Now a simple memory write loop will fill the rectangle
//
// for (i = 0; i < ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 1); i++) {
// WriteSpiData((color >> 4) & 0xFF);
// WriteSpiData(((color & 0xF) << 4) | ((color >> 8) & 0xF));
// WriteSpiData(color & 0xFF);
// }
//
// In the case of an unfilled rectangle, drawing four lines with the Bresenham line
// drawing algorithm is reasonably efficient.
//
// Author: James P Lynch July 7, 2007
// *****************************************************************************************
void NokiaLCD::LCDSetRect(int x0, int y0, int x1, int y1, unsigned char fill, int color) 
{
  int xmin, xmax, ymin, ymax;
  int i;

  // check if the rectangle is to be filled
  if (fill == FILL) 
  {
    // best way to create a filled rectangle is to define a drawing box
    // and loop two pixels at a time
    // calculate the min and max for x and y directions
    xmin = (x0 <= x1) ? x0 : x1;
    xmax = (x0 > x1) ? x0 : x1;
    ymin = (y0 <= y1) ? y0 : y1;
    ymax = (y0 > y1) ? y0 : y1;

    // specify the controller drawing box according to those limits
    // Row address set (command 0x2B)
    sendCMD(PASET);
    sendData(xmin);
    sendData(xmax);

    // Column address set (command 0x2A)
    sendCMD(CASET);
    sendData(ymin);
    sendData(ymax);

    // WRITE MEMORY
    sendCMD(RAMWR);

    // loop on total number of pixels / 2
    for (i = 0; i < ((((xmax - xmin + 1) * (ymax - ymin + 1)) / 2) + 1); i++)
    {
      // use the color value to output three data bytes covering two pixels
      // For some reason, it has to send blue first then green and red
      sendData((color << 4) | ((color & 0xF0) >> 4));
      sendData(((color >> 4) & 0xF0) | (color & 0x0F));
      sendData((color & 0xF0) | (color >> 8));  
    }
  } 
  else 
  {
    // best way to draw un unfilled rectangle is to draw four lines
    LCDSetLine(x0, y0, x1, y0, color);
    LCDSetLine(x0, y1, x1, y1, color);
    LCDSetLine(x0, y0, x0, y1, color);
    LCDSetLine(x1, y0, x1, y1, color);
  }
}

// *************************************************************************************
// LCDSetCircle.c
//
// Draws a line in the specified color at center (x0,y0) with radius
//
// Inputs: x0 = row address (0 .. 131)
// y0 = column address (0 .. 131)
// radius = radius in pixels
// color = 12-bit color value rrrrggggbbbb
//
// Returns: nothing
//
// Author: Jack Bresenham IBM, Winthrop University (Father of this algorithm, 1962)
//
// Note: taken verbatim Wikipedia article on Bresenham's line algorithm
// http://www.wikipedia.org
//
// *************************************************************************************
void NokiaLCD::LCDSetCircle(int x0, int y0, int radius, int color) 
{
  int f = 1 - radius;
  int ddF_x = 0;
  int ddF_y = -2 * radius;
  int x = 0;
  int y = radius;
  LCDSetPixel(x0, y0 + radius, color);
  LCDSetPixel(x0, y0 - radius, color);
  LCDSetPixel(x0 + radius, y0, color);
  LCDSetPixel(x0 - radius, y0, color);
  while (x < y) 
  {
    if (f >= 0) 
	{
      y--;
      ddF_y += 2;
      f += ddF_y;
    }
    x++;
    ddF_x += 2;
    f += ddF_x + 1;
    LCDSetPixel(x0 + x, y0 + y, color);
    LCDSetPixel(x0 - x, y0 + y, color);
    LCDSetPixel(x0 + x, y0 - y, color);
    LCDSetPixel(x0 - x, y0 - y, color);
    LCDSetPixel(x0 + y, y0 + x, color);
    LCDSetPixel(x0 - y, y0 + x, color);
    LCDSetPixel(x0 + y, y0 - x, color);
    LCDSetPixel(x0 - y, y0 - x, color);
   }
}
// *************************************************************************************
// LCDSetPixel.c
//
// Lights a single pixel in the specified color at the specified x and y addresses
//
// Inputs: x = row address (0 .. 131)
// y = column address (0 .. 131)
// color = 12-bit color value rrrrggggbbbb
// rrrr = 1111 full red
// :
// 0000 red is off
//
// gggg = 1111 full green
// :
// 0000 green is off
//
// bbbb = 1111 full blue
// :
// 0000 blue is off
//
// Returns: nothing
//
// Note: see lcd.h for some sample color settings
//
// Author: James P Lynch July 7, 2007
// Modified: Gravitech December 20, 2008
// *************************************************************************************
void NokiaLCD::LCDSetPixel(byte x, byte y, int color) 
{
  LCDSetXY(x, y);
  sendCMD(RAMWR);
  // For some reason, it has to send blue first then green and red
  sendData((color << 4) | ((color & 0xF0) >> 4));
  sendData(((color >> 4) & 0xF0));
  sendCMD(NOP);
}
// *****************************************************************************
// LCDSetXY.c
//
// Sets the Row and Column addresses
//
// Inputs: x = row address (0 .. 131)
// y = column address (0 .. 131)
//
//
// Returns: nothing
//
// Author: James P Lynch July 7, 2007
// Modified: Gravitech December 20, 2008
// *****************************************************************************
void NokiaLCD::LCDSetXY(byte x, byte y) 
{
  // Row address set (command 0x2B)
  sendCMD(PASET);
  sendData(x);
  sendData(x);

  // Column address set (command 0x2A)
  sendCMD(CASET);
  sendData(y);
  sendData(y);
}
